# seckill
a seckill system

##### 概述
基于微服务设计

最外层监听服务端口

使用etcd作为服务发现

内部提供几个组件：
1. 用户管理组件，提供注册认证能力（完成认证后接入层使用jwc进行签署，之后基于jwc进行服务）
2. 商品管理组件
3. 支付组件（先假设可以通过某种方式充值）
4. 商品秒杀组件（用于支撑秒杀限流削峰

其中各部分的设计

商品管理组件
    认为实际对商品的操作是一个低频操作，因此在这个组件里面是直接对商品的数据库进行操作的，
    商品 curd(商品项， 库存， 单价)

    客户：
        获取商品列表(SELECT * FROM PDT_LIST WHERE TYPE != SECKILL_PDT)
        购买商品(需要查询加修改->事务)
        ->购买成功
            ->创建订单
            ->提交支付任务，并将订单推入延迟队列（10min）
                ->订单处理者去获取死信队列数据，拿出订单号，并根据订单号查询支付数据库
                    ->支付成功
                    ->未查询到支付订单，回退订单,库存+1
                        ->回复死信队列完成订单处理

            ->响应用户，返回订单号（同时告诉用户支付超时时间为5min）
        ->失败
            ->响应用户

    商户：

支付组件：
    支持用户向xx订单支付xx元（这部分就草率一点，主要是为了流程完整）
    支持用户充值

商品秒杀组件：
    商家：
        推送秒杀商品
            创建商品，预热加载到redis
                如果是单机，自然加载redis后就已经解决了一切问题，后续崩了大不了重新加载，
                但我在想，如果要支持横向扩展，那显然缓存的内容和数据库的内容是存在不一致情况，
                比如一个商品在另外的服务器秒杀了怎么办，
                那我想到的第一个方式就是，当前真实库存2000
                    一个商品在每台服务器上，可以先各自缓存一定的数量，然后在数据库中预先扣除，之后每隔1min或是20s回刷一次数据
            

用户管理组件：
    用户登录注册...            